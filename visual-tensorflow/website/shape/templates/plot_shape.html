<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Plot Shape</title>
    <script src="../static/jslibs/dat.gui.js"></script>
    <script src="/static/jslibs/jquery.min.js"></script>
    <script src="../static/jslibs/Chart.bundle.js"></script>
    <!-- <link rel="stylesheet" href="css/styles.css?v=1.0"> -->
</head>

<body>
    <div id="plot"></div>
    <div width="800" height="400">
        <div style="max-width:800px; max-height:400px">
            <canvas id="chart" width="100%"></canvas>
        </div>
    </div>
    <div style="padding-left:275px;padding-top:50px" id="frame"></div>

    <script type="text/javascript">
        /***************************************************************************************************************
        * Global variables
        ***************************************************************************************************************/
        var data = {{ data|safe }};     // load data from Flask using Jinja
        var chart;
        console.log(data);

        /***************************************************************************************************************
        * Set up dat gui
        ***************************************************************************************************************/
        var DatGui = function() {
            // Default values
            this.view = 'One video';

            // One Video View - intialize
            var oneVideo = {};
            oneVideo.format = 'film';
            oneVideo.dynamicRange = true;
            oneVideo.films = {};
            oneVideo.films.windowSize = 600;
            oneVideo.films.video = data.format2titles['film'][0];
            oneVideo.shorts = {};
            oneVideo.shorts.windowSize = 60;
            oneVideo.shorts.video = data.format2titles['short'][0];
            this.oneVideo = oneVideo;

            // Clusters View - intialize
            var clusters = {};
            clusters.format = 'film';
            clusters.dynamicRange = false;
            clusters.k = Object.keys(data.clusters.films)[0];
            clusters.focusOnKth = 'all';
            this.clusters = clusters;
        };

        /***************************************************************************************************************
        * On window load
        ***************************************************************************************************************/
        window.onload = function() {
            var datgui = new DatGui();
            var gui = new dat.GUI({width: 400});

            /***********************************************************************************************************
             * Manage views
             **********************************************************************************************************/
            var guiView = gui.add(datgui, 'view', ['One video', 'Clusters']);

            guiView.onFinishChange(function(view) {
                removeViewSpecificGUI();
                if (view == 'One video') {
                    addOneVideoGUI();
                    drawOneVideo(datgui);
                    showImage("../static/videos/" + data.framepaths[0], 256, 256, '');
                } else if (view == 'Clusters') {
                    removeFrame();
                    addClustersGUI();
                    drawClusters(datgui);
                }
            });

            // Remove all but the first controller (the view controller)
            function removeViewSpecificGUI() {
                numControllers = gui.__controllers.length;
                for (var i = 0; i < numControllers - 1; i++) {
                    gui.__controllers[1].remove();
                }
            }

            /***********************************************************************************************************
             * One video view
             **********************************************************************************************************/
            function addOneVideoGUI() {
                // Set ranges, values
                var guiFormats = gui.add(datgui.oneVideo, 'format', ['film', 'short']);
                var guiR = gui.add(datgui.oneVideo, 'dynamicRange');
                var guiW = gui.add(datgui.oneVideo.films, 'windowSize').min(1).max(1500).step(1);
                var guiV = gui.add(datgui.oneVideo.films, 'video', data.format2titles['film']);

                // Dat Gui Handlers
                guiFormats.onFinishChange(function(format) {
                    // Remove list of videos controller; add titles for that format; swap order of controllers to get back in place
                    gui.__controllers[3].remove();  // window
                    gui.__controllers[3].remove();  // video
                    var guiFormatParams, windowMax;
                    if (format == 'film') {
                        guiFormatParams = datgui.oneVideo.films;
                        windowMax = 1500;
                    } else if (format == 'short') {
                        guiFormatParams = datgui.oneVideo.shorts;
                        windowMax = 150;
                    }
                    guiW = gui.add(guiFormatParams, 'windowSize').min(1).max(windowMax).step(1);
                    guiV = gui.add(guiFormatParams, 'video', data.format2titles[format]);
                    addFinishChangeHandlers(guiW, guiV);

                    // Get new predictions
                    getUpdatedPreds(guiFormatParams.video, guiFormatParams.windowSize); }
                );
                function addFinishChangeHandlers(guiW, guiV) {
                    guiW.onFinishChange(function(windowSize) {
                        var title = datgui.oneVideo.format == 'film' ? datgui.oneVideo.films.video : datgui.oneVideo.shorts.video;
                        getUpdatedPreds(title, windowSize);
                    });
                    guiV.onFinishChange(function(title) {
                        var windowSize = datgui.oneVideo.format == 'film' ? datgui.oneVideo.films.windowSize : datgui.oneVideo.shorts.windowSize;
                        getUpdatedPreds(title,windowSize);
                    });
                }
                addFinishChangeHandlers(guiW, guiV);
                guiR.onFinishChange(function() { drawOneVideo(datgui); });
            }

            /***********************************************************************************************************
             * Clusters view
             **********************************************************************************************************/
            function addClustersGUI() {
                // Set ranges, initial values
                var guiFormats = gui.add(datgui.clusters, 'format', ['film', 'short']);
                var guiR = gui.add(datgui.clusters, 'dynamicRange');
                var formatKClusters = data.clusters[datgui.clusters.format + 's'];
                var guiK = gui.add(datgui.clusters, 'k', Object.keys(formatKClusters));
                var guiFocusOnKth = gui.add(datgui.clusters, 'focusOnKth', ['all'].concat(getKIndices(datgui.clusters.k)));
                // Handlers
                guiFormats.onFinishChange(function(format) {
                    // Remove k-related controllers to get list of available k's for that format
                    gui.__controllers[4].remove();
                    gui.__controllers[3].remove();
                    var formatKClusters;
                    if (format == 'film') {
                        formatKClusters = data.clusters[datgui.clusters.format + 's'];

                    } else if (format == 'short') {
                        formatKClusters = data.clusters[datgui.clusters.format + 's'];
                    }
                    datgui.clusters.k =  Object.keys(formatKClusters)[0];
                    guiK = gui.add(datgui.clusters, 'k', Object.keys(formatKClusters));
                    datgui.clusters.focusOnKth =  'all';
                    guiFocusOnKth = gui.add(datgui.clusters, 'focusOnKth', ['all'].concat(getKIndices(datgui.clusters.k)));

                    addFinishChangeHandlers(guiK, guiFocusOnKth);
                    drawClusters(datgui);
                });
                function addFinishChangeHandlers(guiK, guiFocusOnKth) {
                    guiK.onFinishChange(function() {
                        // Remove and add focusOnKth to have proper range
                        gui.__controllers[4].remove();
                        datgui.clusters.focusOnKth =  'all';
                        guiFocusOnKth = gui.add(datgui.clusters, 'focusOnKth', ['all'].concat(getKIndices(datgui.clusters.k)));

                        addFinishChangeHandlers(guiK, guiFocusOnKth);
                        drawClusters(datgui);
                    });
                    guiFocusOnKth.onFinishChange(function() { drawClusters(datgui); });
                }
                addFinishChangeHandlers(guiK, guiFocusOnKth);
                guiR.onFinishChange(function() { drawClusters(datgui); });

                // Return array [0,k-1] (i.e. indices of centroids)
                function getKIndices(k) {
                    var indices = [];
                    for (var i = 0; i < k; i++) {
                        indices.push(i);
                    }
                    return indices
                }
            }


            /***********************************************************************************************************
             * Draw initial
             **********************************************************************************************************/
            addOneVideoGUI();
            showImage("../static/videos/" + data.framepaths[0], 256, 256, '');
            drawOneVideo(datgui);

            /***********************************************************************************************************
             * Some other handlers (should probably be moved somewhere)
             **********************************************************************************************************/
            function getUpdatedPreds(title, windowSize) {
                $.ajax({
                    url: '/api/pred/' + title + '/' + windowSize,
                    type: 'GET',
                    success: function(resp) {
                        reset_and_redraw(resp, redraw_callback);
                    },
                    error: function(xhr, status, err) {
                        console.log(err);
                    }
                })
            }
            function reset_and_redraw(resp, redraw_callback) {
                data.preds = resp.preds;
                data.framepaths = resp.framepaths;
                redraw_callback();
            }
            function redraw_callback() {
                showImage("/static/videos/" + data.framepaths[0], 256, 256, '');
                drawOneVideo(datgui);
            }
        }


        /***************************************************************************************************************
        * Utility functions
        ***************************************************************************************************************/
        function showImage(src, width, height, alt) {
            var frameElement = document.getElementById("frame");
            if (frameElement.firstChild) {      // if image element already exists
                frameElement.firstChild.src = src;
            } else {                            // make element and append to DOM
                var img = document.createElement("img");
                img.src = src;
                img.width = width;
                img.height = height;
                img.alt = alt;
                frameElement.appendChild(img);
            }
        }
        function removeFrame() {
            $('img').remove();
        }

        /***************************************************************************************************************
        * Draw chart for one image view - show images on hover
        ***************************************************************************************************************/
        function drawOneVideo(datgui) {
            // Each label is the timestamp hr:min:sec in the video
            function getLabels(data) {
                var numSec = data.length;
                var labels = [];
                for (var i = 0; i < numSec; i++) {
                  labels.push(formatSeconds(i));
                }
                return labels;
            }
            function formatSeconds(seconds) {
                var date = new Date(null);
                date.setSeconds(seconds); // specify value for SECONDS here
                return date.toISOString().substr(11, 8);
            }

            // Each object in dataset array corresponds to one line
            // e.g. one line for each emotion
            var dataset = [];
            for (var key in data.preds) {
                dataset.push({
                    label: key,
                    borderWidth: 0.1,
                    data: data.preds[key],
                    backgroundColor: "rgba(15, 171, 182, 0.75)"
                })
            }
            // Use first set
            var labels = getLabels(data.preds[Object.keys(data.preds)[0]]);
            var chartData = {
                labels: labels,
                datasets: dataset
            };

            // Options
            var options = {
                global: {
                    responsive: true,
                    maintainAspectRatio: false
                },
                elements: {   // Don't show individual points on line graph
                    point:{
                        radius: 0
                    }
                },
                tooltips: {     // tooltip for points on current mouse x-axis position
                    mode: 'index',
                    intersect: false
                },
                scales: {
                    xAxes: [{
                        ticks: {
                          autoSkipPadding: 50
                        }
                    }],
                    yAxes: datgui.oneVideo.dynamicRange ? [] : [{   // Y-axis from 0 to 1
                        ticks: {
                            min: 0.0,
                            max: 1.0
                        }
                    }]
                },
                hover: {
                    onHover: function (e) {
                        if (e[0]) {
                            var frameIdx = e[0]._index;
                            showImage("../static/videos/" + data.framepaths[frameIdx], 256, 256, '');
                        }
                    },
                    mode: 'index',
                    intersect: false
                },
                animation: {
                    duration: 0
                }
            };

            var ctx = $("#chart");
            if (chart) {
                chart.destroy();
            }

            chart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: options
            });
        }

        /***************************************************************************************************************
        * Draw chart for cluster view
        ***************************************************************************************************************/
        function drawClusters(datgui) {
            var COLORS = [
                [78,179,211],   // blue
                [252,78,42],    // red
                [221,52,151],   // magenta
                [8,64,129],     // dark blue
                [128,0,38],     // dark burnt red
                [250,159,181],  // peach/pink
                [65,174,118],   // green
                [254,178,76],   // orange / yellow
                [73,0,106],     // dark violet
                [0,109,44]      // dark green
            ];

            // Get dataset
            // Each object in dataset array corresponds to one line
            var dataset = [];
            var curClusters = data.clusters[datgui.clusters.format + 's'][datgui.clusters.k];   // film -> films
            for (var i = 0; i < curClusters.centroids.length; i++) {
                // Skip if focusOnKth but not focusing on this centroid
                if (datgui.clusters.focusOnKth != 'all') {
                    if (i != datgui.clusters.focusOnKth) {
                        continue;
                    }
                }
                // Add point
                var rgb = COLORS[i];
                var opacity = ",0.75)";
                var rgba = "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + opacity;
                dataset.push({
                    label: i,
                    data: curClusters.centroids[i],
                    borderWidth: 2,
                    borderColor: rgba,
                    backgroundColor: rgba,
                    fill: false
                });
            }

            // Display assignments if focusOnKth
            // TODO: show closest points
            if (datgui.clusters.focusOnKth != 'all') {
                var kthClustering = data.clusters[datgui.clusters.format + 's'][datgui.clusters.k];
                var assignments = kthClustering.assignments[datgui.clusters.focusOnKth];
                for (var i = 0; i < assignments.length; i++) {
                    var title = data.ts_idx2title[datgui.clusters.format + 's'][assignments[i]];
                    var series = data.ts[datgui.clusters.format + 's'][assignments[i]];
                    console.log(title);

                    var hex = getRandomHexColor();
                    var rgb = hexToRGB(hex);
                    var opacity = ",0.2)";
                    var rgba = "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + opacity;
                    dataset.push({
                        label: title,
                        data: series,
                        borderWidth: 1,
                        borderColor: rgba,
                        backgroundColor: rgba,
                        fill: false
                    });

                    // Too many lines!
                    if (i == 10) {
                        break;
                    }
                }
            }
            var labels = [];
            for (var i = 0; i < curClusters.centroids[0].length; i++) {
                labels.push(i);
            }
            var chartData = {
                labels: labels,
                datasets: dataset
            };

            // Utility to generator colors
            function getRandomHexColor() {
                var letters = '0123456789ABCDEF';
                var color = '#';
                for (var i = 0; i < 6; i++ ) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            }
            function hexToRGB(hex) {
                var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            // Options for chartjs
            var options = {
                global: {
                    responsive: false,
                    maintainAspectRatio: false,
                    responsiveAnimationDuration: 0
                },
                elements: {   // Don't show individual points on line graph
                    point:{
                        radius: 0
                    }
                },
                tooltips: {     // tooltip for points on current mouse x-axis position
                    mode: 'index',
                    intersect: false
                },
                scales: {
                    xAxes: [{
                        display: false
                    }],
                    yAxes: datgui.clusters.dynamicRange ? [] : [{   // Y-axis from 0 to 1
                        ticks: {
                            min: 0.0,
                            max: 1.0
                        }
                    }]
                },
                animation: {
                    duration: 0
                }
            };

            var ctx = $("#chart");
            if (chart) {
                chart.destroy();
            }
            chart = new Chart(ctx, {
                    type: 'line',
                    data: chartData,
                    options: options
                });
            }

    </script>
</body>
</html>